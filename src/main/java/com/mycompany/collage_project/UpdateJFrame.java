package com.mycompany.collage_project; // Or your appropriate package

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;

public class UpdateJFrame extends javax.swing.JFrame {

    private Connection connection;
    private DefaultTableModel tableModel;
    private Map<String, JTextField> editFieldsMap; // To hold dynamic edit fields
    private JPanel editFieldsPanelContainer; // Panel to hold the dynamic fields

    /**
     * Creates new form UpdateDeleteSearchFrame
     */
    public UpdateJFrame() {
        // Initialize database connection first
        connection = databaseConnection.getConnection(); // Use your existing connection class
        if (connection == null) {
            JOptionPane.showMessageDialog(this,
                    "Database connection failed. Please check console.",
                    "Connection Error",
                    JOptionPane.ERROR_MESSAGE);
            // Optionally disable components or exit if connection is crucial
            // System.exit(1); // Or handle more gracefully
        }

        editFieldsMap = new HashMap<>();
        initComponents(); // Initialize Swing components (generated by GUI builder or manually)
        setupListeners(); // Setup custom listeners
        initializeForm(); // Initial setup logic
    }

    //<editor-fold defaultstate="collapsed" desc="Generated Code - Manual or GUI Builder">
    // This method would typically be generated by a GUI builder like NetBeans.
    // I'm creating a plausible structure manually here.
    @SuppressWarnings("unchecked")
    private void initComponents() {

        mainPanel = new javax.swing.JPanel();
        titleLabel = new javax.swing.JLabel();
        controlsPanel = new javax.swing.JPanel();
        searchByLabel = new javax.swing.JLabel();
        searchColumnComboBox = new javax.swing.JComboBox<>();
        searchTextField = new javax.swing.JTextField();
        tableNameLabel = new javax.swing.JLabel();
        tableComboBox = new javax.swing.JComboBox<>();
        searchButton = new javax.swing.JButton();
        tableScrollPane = new javax.swing.JScrollPane();
        resultTable = new javax.swing.JTable();
        editPanel = new javax.swing.JPanel();
        editTitleLabel = new javax.swing.JLabel();
        // Container for dynamically added fields
        editFieldsPanelContainer = new javax.swing.JPanel();
        actionButtonsPanel = new javax.swing.JPanel();
        saveButton = new javax.swing.JButton();
        deleteButton = new javax.swing.JButton();
        backButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE); // Dispose on close to go back
        setTitle("Update / Delete / Search");

        // --- Title ---
        titleLabel.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        titleLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        titleLabel.setText("Update / Delete / Search Page");

        // --- Controls Panel (Search, Table Selection) ---
        controlsPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        searchByLabel.setText("Search By Column:");
        tableNameLabel.setText("Table Name:");
        searchButton.setText("Search");

        // Layout for controlsPanel (Example using GroupLayout - Adapt as needed)
        javax.swing.GroupLayout controlsPanelLayout = new javax.swing.GroupLayout(controlsPanel);
        controlsPanel.setLayout(controlsPanelLayout);
        controlsPanelLayout.setHorizontalGroup(
                controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(controlsPanelLayout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(searchByLabel)
                                        .addComponent(searchColumnComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(searchTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                                .addGap(18, 18, 18)
                                .addGroup(controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(tableNameLabel)
                                        .addComponent(tableComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(searchButton, javax.swing.GroupLayout.PREFERRED_SIZE, 88, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())
        );
        controlsPanelLayout.setVerticalGroup(
                controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(controlsPanelLayout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(searchByLabel)
                                        .addComponent(tableNameLabel))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(controlsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(searchColumnComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(searchTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(tableComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(searchButton))
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        // --- Table ---
        tableModel = new DefaultTableModel() {
            // Make table cells non-editable by default
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        resultTable.setModel(tableModel);
        resultTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION); // Allow only one row selection
        tableScrollPane.setViewportView(resultTable);

        // --- Edit Panel ---
        editPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Edit Selected Row"));
        editPanel.setLayout(new BorderLayout()); // Use BorderLayout for structure

        // Container Panel for dynamic fields with BoxLayout
        editFieldsPanelContainer.setLayout(new BoxLayout(editFieldsPanelContainer, BoxLayout.Y_AXIS));
        JScrollPane editFieldsScrollPane = new JScrollPane(editFieldsPanelContainer); // Make it scrollable if many fields
        editPanel.add(editFieldsScrollPane, BorderLayout.CENTER);

        // --- Action Buttons Panel ---
        actionButtonsPanel.setLayout(new FlowLayout(FlowLayout.RIGHT)); // Align buttons to the right
        saveButton.setText("Save Changes");
        deleteButton.setText("Delete Selected");
        backButton.setText("Back to Home");
        actionButtonsPanel.add(saveButton);
        actionButtonsPanel.add(deleteButton);
        actionButtonsPanel.add(backButton);

        // --- Main Layout (using GroupLayout for example) ---
        javax.swing.GroupLayout mainPanelLayout = new javax.swing.GroupLayout(mainPanel);
        mainPanel.setLayout(mainPanelLayout);
        mainPanelLayout.setHorizontalGroup(
                mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(mainPanelLayout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(titleLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(controlsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(tableScrollPane)
                                        .addComponent(editPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(actionButtonsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addContainerGap())
        );
        mainPanelLayout.setVerticalGroup(
                mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(mainPanelLayout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(titleLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(controlsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(tableScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE) // Give table more space
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(editPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE) // Edit panel takes space too
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(actionButtonsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())
        );

        // --- Add Main Panel to Frame ---
        getContentPane().add(mainPanel, java.awt.BorderLayout.CENTER);

        pack(); // Adjust frame size to fit components
        setLocationRelativeTo(null); // Center on screen
    }// </editor-fold>

    private void initializeForm() {
        // Populate the table selection ComboBox
        tableComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"student", "instractor", "course", "department"}));
        tableComboBox.setSelectedIndex(-1); // No initial selection

        // Disable components that require a table/row selection initially
        searchColumnComboBox.setEnabled(false);
        searchTextField.setEnabled(false);
        searchButton.setEnabled(false);
        saveButton.setEnabled(false);
        deleteButton.setEnabled(false);
        editFieldsPanelContainer.setVisible(false); // Hide edit panel initially
        clearEditFields(); // Clear any potential leftover fields
    }

    private void setupListeners() {
        // Listener for Table Selection ComboBox
        tableComboBox.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleTableSelection();
            }
        });

        // Listener for Search Button
        searchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleSearchAction();
            }
        });

        // Listener for Table Row Selection
        resultTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent event) {
                // Check if the selection change is finished and a row is selected
                if (!event.getValueIsAdjusting() && resultTable.getSelectedRow() != -1) {
                    handleTableRowSelection();
                } else if (resultTable.getSelectedRow() == -1) {
                    // No row selected, disable buttons and clear fields
                    saveButton.setEnabled(false);
                    deleteButton.setEnabled(false);
                    clearEditFields();
                    editFieldsPanelContainer.setVisible(false);
                }
            }
        });

        // Listener for Save Button
        saveButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleSaveAction();
            }
        });

        // Listener for Delete Button
        deleteButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleDeleteAction();
            }
        });

        // Listener for Back Button
        backButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleBackAction();
            }
        });
    }

    private void handleTableSelection() {
        String selectedTable = (String) tableComboBox.getSelectedItem();
        if (selectedTable == null) {
            initializeForm(); // Reset if selection is cleared
            return;
        }

        // Enable search components
        searchColumnComboBox.setEnabled(true);
        searchTextField.setEnabled(true);
        searchButton.setEnabled(true);

        // Clear previous table data and columns
        tableModel.setRowCount(0);
        tableModel.setColumnCount(0);

        // Clear previous edit fields
        clearEditFields();
        editFieldsPanelContainer.setVisible(false);
        saveButton.setEnabled(false); // Disable save/delete until row is selected
        deleteButton.setEnabled(false);

        List<String> columnNames = getColumnNamesForTable(selectedTable);

        // Populate Search Column ComboBox
        searchColumnComboBox.setModel(new DefaultComboBoxModel<>(columnNames.toArray(new String[0])));
        if (!columnNames.isEmpty()) {
            searchColumnComboBox.setSelectedIndex(0); // Default to the first column
        }

        // Set Table Headers
        tableModel.setColumnIdentifiers(columnNames.toArray());

        // Create Edit Fields (but keep them hidden for now)
        createEditFieldsSwing(columnNames, selectedTable);

        // Optional: Perform an initial search to show all data
        performSearch(""); // Pass empty string to show all
    }

    private List<String> getColumnNamesForTable(String tableName) {
        List<String> columnNames = new ArrayList<>();
        // Define columns based on table name (matching JavaFX logic)
        switch (tableName) {
            case "student":
                columnNames.add("student_id");
                columnNames.add("first_name");
                columnNames.add("last_name");
                columnNames.add("phone");
                break;
            case "instractor":
                columnNames.add("instractor_id");
                columnNames.add("first_name");
                columnNames.add("last_name");
                columnNames.add("phone");
                break;
            case "course":
                columnNames.add("course_id");
                columnNames.add("course_name");
                columnNames.add("duration");
                break;
            case "department":
                // Match the order used in JavaFX SELECT and edit population
                columnNames.add("department_name"); // PK for department
                columnNames.add("location");
                // Add head_instructor_id if you need to display/edit it
                // columnNames.add("head_instractor_id");
                break;
        }
        // Alternative: Fetch column names dynamically from ResultSetMetaData
        // This is more robust if the schema changes.
        /*
        if (connection != null) {
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("SELECT * FROM " + tableName + " WHERE 1=0")) { // Get metadata without data
                ResultSetMetaData metaData = rs.getMetaData();
                int count = metaData.getColumnCount();
                for (int i = 1; i <= count; i++) {
                    columnNames.add(metaData.getColumnName(i));
                }
            } catch (SQLException e) {
                showError("Error fetching column names: " + e.getMessage());
                e.printStackTrace();
            }
        }
         */
        return columnNames;
    }

    private void createEditFieldsSwing(List<String> columnNames, String selectedTable) {
        editFieldsMap.clear();
        editFieldsPanelContainer.removeAll(); // Clear previous fields

        // Determine start index for editable fields (skip ID usually)
        int startIndex = 1; // Default: Skip first column (ID)
        String idColumnName = columnNames.isEmpty() ? "" : columnNames.get(0);

        if ("department".equals(selectedTable)) {
            startIndex = 0; // Department uses department_name (index 0) as editable PK potentially
            // But usually, you wouldn't allow editing the primary key directly.
            // Let's assume department_name is the key *but* we allow editing location.
            idColumnName = "department_name"; // The key for WHERE clause
            startIndex = 1; // Edit location (index 1)
            // Only add fields for 'location'
            if (columnNames.size() > 1) {
                String colName = columnNames.get(1); // location
                JPanel fieldPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                fieldPanel.add(new JLabel(colName + ":"));
                JTextField textField = new JTextField(20); // Adjust size
                fieldPanel.add(textField);
                editFieldsPanelContainer.add(fieldPanel);
                editFieldsMap.put(colName, textField);
            }

        } else {
            // Standard case: Add editable fields for columns starting from startIndex
            for (int i = startIndex; i < columnNames.size(); i++) {
                String columnName = columnNames.get(i);
                JPanel fieldPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                fieldPanel.add(new JLabel(columnName + ":"));
                JTextField textField = new JTextField(20); // Adjust size
                fieldPanel.add(textField);
                editFieldsPanelContainer.add(fieldPanel);
                editFieldsMap.put(columnName, textField); // Store field for later access
            }
        }

        editFieldsPanelContainer.revalidate();
        editFieldsPanelContainer.repaint();
        // Keep it hidden until a row is selected
        editFieldsPanelContainer.setVisible(false);
    }

    private void handleSearchAction() {
        String selectedTable = (String) tableComboBox.getSelectedItem();
        String selectedColumn = (String) searchColumnComboBox.getSelectedItem();
        String searchQuery = searchTextField.getText();

        if (selectedTable == null || selectedColumn == null) {
            showError("Please select a table and a column to search by.");
            return;
        }
        performSearch(searchQuery);
    }

    private void performSearch(String searchQuery) {
        String selectedTable = (String) tableComboBox.getSelectedItem();
        String selectedColumn = (String) searchColumnComboBox.getSelectedItem();

        if (selectedTable == null || selectedColumn == null) {
            // Should not happen if called correctly, but good practice
            return;
        }

        // Construct SQL query
        // IMPORTANT: Using PreparedStatement to prevent SQL Injection vulnerabilities
        String sql = "SELECT * FROM " + selectedTable + " WHERE " + selectedColumn + " LIKE ?";

        // Clear previous results
        tableModel.setRowCount(0);

        if (connection == null) {
            showError("Database connection is not available.");
            return;
        }

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, "%" + searchQuery + "%"); // Add wildcards for LIKE search

            ResultSet rs = pstmt.executeQuery();
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Ensure table columns match metadata (optional, but good practice)
            Vector<String> columnIdentifiers = new Vector<>();
            for (int i = 1; i <= columnCount; i++) {
                columnIdentifiers.add(metaData.getColumnName(i));
            }
            tableModel.setColumnIdentifiers(columnIdentifiers);

            // Populate table model with results
            while (rs.next()) {
                Vector<Object> row = new Vector<>();
                for (int i = 1; i <= columnCount; i++) {
                    row.add(rs.getObject(i)); // Use getObject for flexibility
                }
                tableModel.addRow(row);
            }

            rs.close();

        } catch (SQLException e) {
            showError("Database search error: " + e.getMessage());
            e.printStackTrace(); // Log detailed error
        } catch (Exception e) {
            showError("An unexpected error occurred during search: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleTableRowSelection() {
        int selectedRow = resultTable.getSelectedRow();
        if (selectedRow == -1) {
            // No row selected or selection cleared
            clearEditFields();
            editFieldsPanelContainer.setVisible(false);
            saveButton.setEnabled(false);
            deleteButton.setEnabled(false);
            return;
        }

        // A row is selected, enable buttons and populate fields
        saveButton.setEnabled(true);
        deleteButton.setEnabled(true);
        editFieldsPanelContainer.setVisible(true); // Show the edit fields panel

        String selectedTable = (String) tableComboBox.getSelectedItem();

        // Populate the TextFields in the edit panel
        // The keys in editFieldsMap match the column names *of the editable fields*
        for (Map.Entry<String, JTextField> entry : editFieldsMap.entrySet()) {
            String columnName = entry.getKey();
            JTextField textField = entry.getValue();
            int columnIndex = findColumnIndex(columnName); // Find the column index in the JTable model

            if (columnIndex != -1) {
                Object value = tableModel.getValueAt(selectedRow, columnIndex);
                textField.setText(value != null ? value.toString() : ""); // Set text, handle null
            } else {
                System.err.println("Warning: Column '" + columnName + "' not found in table model for editing.");
                textField.setText(""); // Clear field if column not found
            }
        }
        // Special handling for department if department_name is the key but not in editFieldsMap
        if ("department".equals(selectedTable)) {
            // If you decided to allow editing department_name, you would handle it here.
            // If not, the loop above correctly handles only 'location'.
        }

        // Ensure the panel updates visually
        editFieldsPanelContainer.revalidate();
        editFieldsPanelContainer.repaint();
        // Maybe pack the container or frame if fields cause size changes
        // editPanel.revalidate(); // Or revalidate the parent container
    }

    // Helper to find column index by name (case-insensitive)
    private int findColumnIndex(String columnName) {
        TableColumnModel columnModel = resultTable.getColumnModel();
        for (int i = 0; i < columnModel.getColumnCount(); i++) {
            if (columnModel.getColumn(i).getHeaderValue().toString().equalsIgnoreCase(columnName)) {
                return i;
            }
        }
        return -1; // Not found
    }

    private void clearEditFields() {
        for (JTextField field : editFieldsMap.values()) {
            field.setText("");
        }
        // Also hide the panel containing the fields
        if (editFieldsPanelContainer != null) {
            editFieldsPanelContainer.setVisible(false);
        }
    }

    private void handleSaveAction() {
        // 1. Get Selected Row Index from the JTable
        int selectedRow = resultTable.getSelectedRow();
        if (selectedRow == -1) {
            showError("Please select a row to update.");
            return;
        }

        // 2. Get Selected Table Name from ComboBox
        String selectedTable = (String) tableComboBox.getSelectedItem();
        if (selectedTable == null) {
            showError("No table selected.");
            return;
        }

        // 3. Check Database Connection (ensure 'connection' is a valid member variable)
        if (connection == null) {
            showError("Database connection is not available.");
            return;
        }

        // 4. Build the SQL UPDATE statement dynamically
        StringBuilder sql = new StringBuilder("UPDATE ");
        sql.append(selectedTable).append(" SET "); // Append table name
        List<String> setClauses = new ArrayList<>();
        List<Object> values = new ArrayList<>(); // To hold the values for the 'SET' part

        // Get values from the dynamically created editable fields stored in the map
        // Assumes 'editFieldsMap' is a Map<String, JTextField> holding the editable fields
        if (editFieldsMap == null || editFieldsMap.isEmpty()) {
            showMessage("No editable fields are configured to save.");
            return;
        }
        for (Map.Entry<String, JTextField> entry : editFieldsMap.entrySet()) {
            setClauses.add(entry.getKey() + " = ?"); // Add "columnName = ?"
            values.add(entry.getValue().getText());  // Add the text from the corresponding JTextField
        }

        // Check if there are actually any fields to update
        if (setClauses.isEmpty()) {
            showMessage("No changes detected or no editable fields for this table.");
            return;
        }
        sql.append(String.join(", ", setClauses)); // Join the SET clauses: "col1 = ?, col2 = ?, ..."

        // 5. Determine the WHERE clause based on the table's primary key
        String idColumnName;
        Object idValue;

        // Determine the primary key column name based on the selected table
        switch (selectedTable) {
            case "student":
                idColumnName = "student_id";
                break;
            case "instractor": // Ensure spelling matches table/column name
                idColumnName = "instractor_id"; // Ensure spelling matches table/column name
                break;
            case "course":
                idColumnName = "course_id";
                break;
            case "department":
                idColumnName = "department_name"; // Department uses name as the primary key
                break;
            default:
                showError("Unknown table type for update operation.");
                return;
        }

        // Find the column index of the ID column in the JTable model
        int idColumnIndex = findColumnIndex(idColumnName); // Assumes you have this helper method
        if (idColumnIndex == -1) {
            showError("Critical Error: Could not find the ID column '" + idColumnName + "' in the table model.");
            return;
        }

        // Get the *original* ID value from the selected row in the table model
        try {
            // Assumes 'tableModel' is your DefaultTableModel instance
            idValue = tableModel.getValueAt(selectedRow, idColumnIndex);
            if (idValue == null) {
                // This shouldn't happen for a primary key, but check just in case
                showError("Could not retrieve the ID value for the selected row (ID is null).");
                return;
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // Safety check in case the table structure changed unexpectedly
            showError("Error retrieving ID value: Row or column index is out of bounds.");
            e.printStackTrace(); // Log the detailed error
            return;
        }

        // Append the WHERE clause to the SQL statement
        sql.append(" WHERE ").append(idColumnName).append(" = ?");
        values.add(idValue); // Add the ID value itself to the list of parameters (it's the last one)

        // 6. Prepare and Execute the PreparedStatement
        System.out.println("Executing SQL: " + sql.toString()); // Optional: Log the SQL
        System.out.println("With values: " + values);         // Optional: Log the values

        try (PreparedStatement pstmt = connection.prepareStatement(sql.toString())) {
            // Set the parameters for the PreparedStatement (index starts from 1)
            // Set parameters for the SET clauses first
            for (int i = 0; i < values.size() - 1; i++) { // Iterate up to the second-to-last element
                // Using setObject handles different data types appropriately in most cases
                pstmt.setObject(i + 1, values.get(i));
            }
            // Set the parameter for the WHERE clause (the last element in the 'values' list)
            pstmt.setObject(values.size(), values.get(values.size() - 1));

            // 7. Execute the update and Handle Results
            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                showMessage("Record updated successfully.");
                // Refresh the table data to show the change
                performSearch(searchTextField.getText()); // Re-run the current search

                // --- Ensure the problematic line is REMOVED or COMMENTED OUT ---
                // resultTable.setRowSelectionInterval(selectedRow, selectedRow);
                // Reset the UI state after successful save
                resultTable.clearSelection(); // Clear table selection
                saveButton.setEnabled(false);   // Disable save button
                deleteButton.setEnabled(false); // Disable delete button
                clearEditFields();              // Clear the edit text fields
                if (editFieldsPanelContainer != null) { // Hide the panel containing edit fields
                    editFieldsPanelContainer.setVisible(false);
                }

            } else {
                // Inform the user if no rows were changed. This could happen if the
                // data submitted was identical to the existing data, or if the record
                // was deleted/modified by another process between selection and saving.
                showError("No records were updated. The data might be unchanged, or the record no longer exists as selected.");
                // Decide whether to reset UI state here or leave it as is
            }

            // 8. Catch Potential Exceptions
        } catch (SQLException e) {
            showError("Database update error: " + e.getMessage());
            e.printStackTrace(); // Log the full stack trace for debugging
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the process
            showError("An unexpected error occurred during the save operation: " + e.getMessage());
            e.printStackTrace();
        }
    } // End of handleSaveAction method

    private void handleDeleteAction() {
        int selectedRow = resultTable.getSelectedRow();
        if (selectedRow == -1) {
            showError("Please select a row to delete.");
            return;
        }

        String selectedTable = (String) tableComboBox.getSelectedItem();
        if (selectedTable == null) {
            showError("No table selected.");
            return;
        }

        if (connection == null) {
            showError("Database connection is not available.");
            return;
        }

        // --- Confirm Deletion ---
        int confirmation = JOptionPane.showConfirmDialog(this,
                "Are you sure you want to delete the selected record?",
                "Confirm Deletion",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.WARNING_MESSAGE);

        if (confirmation != JOptionPane.YES_OPTION) {
            return; // User cancelled
        }

        // --- Determine the Key Column and Value ---
        String idColumnName;
        Object idValue;

        switch (selectedTable) {
            case "student":
                idColumnName = "student_id";
                break;
            case "instractor":
                idColumnName = "instractor_id";
                break;
            case "course":
                idColumnName = "course_id";
                break;
            case "department":
                idColumnName = "department_name";
                break;
            default:
                showError("Unknown table type for delete.");
                return;
        }

        int idColumnIndex = findColumnIndex(idColumnName);
        if (idColumnIndex == -1) {
            showError("Could not find the ID column '" + idColumnName + "' in the table.");
            return;
        }
        idValue = tableModel.getValueAt(selectedRow, idColumnIndex);

        // --- Execute Delete ---
        String sql = "DELETE FROM " + selectedTable + " WHERE " + idColumnName + " = ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setObject(1, idValue); // Use setObject for flexibility

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                showMessage("Record deleted successfully.");
                // Refresh the table data
                performSearch(searchTextField.getText()); // Re-run current search
                // Clear edit fields as the row is gone
                clearEditFields();
                editFieldsPanelContainer.setVisible(false);
                saveButton.setEnabled(false);
                deleteButton.setEnabled(false);
            } else {
                showError("No records were deleted. The record might have already been deleted.");
            }

        } catch (SQLException e) {
            // Check for foreign key constraint violations
            if (e.getMessage().toLowerCase().contains("foreign key constraint")) {
                showError("Cannot delete this record because it is referenced by other records (e.g., a student in a department, a course enrollment). Please delete the related records first.");
            } else {
                showError("Database delete error: " + e.getMessage());
            }
            e.printStackTrace();
        } catch (Exception e) {
            showError("An unexpected error occurred during delete: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleBackAction() {
        // Close this window
        this.dispose();

        // Open the main CollageJFrame window again
        // Assumes CollageJFram has a standard constructor and main method structure
        java.awt.EventQueue.invokeLater(() -> {
            new CollageFrame().setVisible(true);
        });
    }

    // Helper methods for showing messages
    private void showMessage(String message) {
        JOptionPane.showMessageDialog(this, message, "Information", JOptionPane.INFORMATION_MESSAGE);
    }

    private void showError(String message) {
        JOptionPane.showMessageDialog(this, message, "Error", JOptionPane.ERROR_MESSAGE);
    }

    // --- Main Method (for testing this frame independently) ---
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (Exception ex) {
            java.util.logging.Logger.getLogger(UpdateJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UpdateJFrame().setVisible(true);
            }
        });
    }

    // --- Variables declaration - Manually defined or from GUI Builder ---
    private javax.swing.JPanel mainPanel;
    private javax.swing.JLabel titleLabel;
    private javax.swing.JPanel controlsPanel;
    private javax.swing.JLabel searchByLabel;
    private javax.swing.JComboBox<String> searchColumnComboBox;
    private javax.swing.JTextField searchTextField;
    private javax.swing.JLabel tableNameLabel;
    private javax.swing.JComboBox<String> tableComboBox;
    private javax.swing.JButton searchButton;
    private javax.swing.JScrollPane tableScrollPane;
    private javax.swing.JTable resultTable;
    private javax.swing.JPanel editPanel;
    private javax.swing.JLabel editTitleLabel;
    // editFieldsPanelContainer is already declared as a member variable
    private javax.swing.JPanel actionButtonsPanel;
    private javax.swing.JButton saveButton;
    private javax.swing.JButton deleteButton;
    private javax.swing.JButton backButton;
    // End of variables declaration
}
